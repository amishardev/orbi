rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isChatParticipant(chatId) {
      // If the chat exists, read participants from the stored resource.
      // If it's a create request the request.resource will be used.
      let chatDoc = exists(/databases/$(database)/documents/chats/$(chatId))
        ? get(/databases/$(database)/documents/chats/$(chatId))
        : (request.resource != null ? request.resource : null);
      return chatDoc != null && chatDoc.data.participants is list && request.auth.uid in chatDoc.data.participants;
    }

    // Communities collection
    match /communities/{communityId} {
      // Read rules: Members can read private communities, anyone can read public ones
      allow list, get: if isAuthenticated() && (
        request.auth.uid in resource.data.members || 
        (resource.data.isPublic == true)
      );

      // Create: authenticated users can create a community where they are admin
      allow create: if isAuthenticated()
        // Required fields validation
        && request.resource.data.keys().hasAll([
          'name', 
          'iconUrl', 
          'adminId', 
          'members', 
          'createdAt', 
          'lastMessageAt', 
          'isPublic', 
          'memberDetails'
        ])
        // Field type validation
        && request.resource.data.name is string
        && request.resource.data.name.size() > 0
        && request.resource.data.name.size() <= 50
        && request.resource.data.iconUrl is string
        && (
          request.resource.data.iconUrl.matches('^https://.*') ||
          request.resource.data.iconUrl.matches('^data:image/.*')
        )
        && request.resource.data.isPublic is bool
        && request.resource.data.memberDetails is map
        // Admin and members validation
        && request.resource.data.adminId == request.auth.uid
        && request.resource.data.members is list
        && request.resource.data.members.size() > 0  // At least admin
        && request.auth.uid in request.resource.data.members
        // Member details validation - must match members array
        && request.resource.data.memberDetails.keys().hasAll(request.resource.data.members)
        && request.resource.data.members.hasAll(request.resource.data.memberDetails.keys());

      // Update: admin can update everything, members can only leave
      allow update: if isAuthenticated() && (
        // Admin can update any field except adminId itself
        (request.auth.uid == resource.data.adminId &&
         request.resource.data.adminId == resource.data.adminId) ||
        // Members can only remove themselves from members array and their details
        (
          request.auth.uid in resource.data.members &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members', 'memberDetails']) &&
          resource.data.members.removeAll(request.resource.data.members).size() == 1 &&
          resource.data.members.removeAll(request.resource.data.members)[0] == request.auth.uid &&
          !request.resource.data.memberDetails.keys().hasAll([request.auth.uid]) &&
          request.resource.data.adminId == resource.data.adminId
        ) ||
        // Allow members to update lastMessageAt when sending a message
        (
          request.auth.uid in resource.data.members &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessageAt'])
        )
      );

      // Delete: only admin can delete the community
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.adminId;

      // Messages subcollection
      match /messages/{messageId} {
        // Read messages if member of parent community
        allow read: if isAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/communities/$(communityId)).data.members;

        // Create message if member and senderId matches auth.uid
        allow create: if isAuthenticated()
          && request.auth.uid in get(/databases/$(database)/documents/communities/$(communityId)).data.members
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.text is string
          && request.resource.data.type in ['text', 'image', 'gif', 'video']
          // User details validation
          && request.resource.data.user is map
          && request.resource.data.user.displayName is string;

        // Updates/deletes: only the sender or community admin can modify messages
        allow update, delete: if isAuthenticated() && (
          request.auth.uid == resource.data.senderId ||
          request.auth.uid == get(/databases/$(database)/documents/communities/$(communityId)).data.adminId
        );
      }

      // Read Receipts subcollection
      match /readReceipts/{userId} {
        // Members can read receipts
        allow read: if isAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/communities/$(communityId)).data.members;
        
        // Users can only write their own receipt
        allow write: if isAuthenticated() && request.auth.uid == userId;
      }
    }

    match /users/{userId} {
      // Anyone can read user profiles
      allow read: if true;
      // Users can only create/update their own profile
      // Users can only create/update their own profile
      // EXCEPTION: Allow other users to update 'followersCount' ONLY IF they are adding/removing themselves as a follower
      allow create: if request.auth.uid == userId;
      allow update: if request.auth != null && (
        request.auth.uid == userId || 
        (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followersCount']) &&
          (
            request.resource.data.followersCount == resource.data.followersCount + 1 ||
            request.resource.data.followersCount == resource.data.followersCount - 1
          )
        )
      );

      // Followers subcollection
      match /followers/{followerId} {
        // Anyone can read followers list
        allow read: if true;

        // Only the follower can create/delete their own follower record
        // Also prevent self-following
        allow create: if isAuthenticated() && 
          request.auth.uid == followerId &&  // Only the follower can write
          followerId != userId;              // Prevent self-following

        allow delete: if isAuthenticated() && (
          request.auth.uid == followerId ||  // Follower can unfollow
          request.auth.uid == userId         // User can remove followers
        );
      }

      // Following subcollection
      match /following/{targetUserId} {
        // Anyone can read following list
        allow read: if true;

        // User can only add/remove from their own following list
        // Also prevent self-following
        allow create: if isAuthenticated() && 
          request.auth.uid == userId &&      // Must be the user's own following list
          userId != targetUserId &&          // Prevent self-following
          // Validate the document data
          request.resource.data.keys().hasAll(['username', 'displayName']) &&
          request.resource.data.userId == targetUserId;

        allow delete: if isAuthenticated() && 
          request.auth.uid == userId;        // Only owner can unfollow
      }
    }

    match /chats/{chatId} {
      // Allow listing chats and reading individual chats if authenticated
      allow read: if isAuthenticated();

      // Simple create rule - just check auth and basic structure
      allow create: if isAuthenticated() && 
        request.resource.data.participants is list &&
        request.auth.uid in request.resource.data.participants;

      // A user can update a chat if they are a participant
      allow update: if isAuthenticated() && request.auth.uid in resource.data.participants;

      // Messages subcollection rules
      match /messages/{messageId} {
        // A user can read messages in a chat if they are a participant of that chat
        allow read: if isAuthenticated() && isChatParticipant(chatId);
        
        // A user can create a message if they are a participant and the senderId is their own.
        // Accept 'text' (client uses this) and don't require client-sent createdAt (serverTimestamp used).
        allow create: if isAuthenticated() &&
          isChatParticipant(chatId) &&
          request.resource.data.senderId == request.auth.uid &&
          request.resource.data.keys().hasAny(['text', 'content']) &&
          request.resource.data.senderId is string;
      }
    }

    match /notifications/{userId} {
      match /items/{notificationId} {
          // Allow a user to read and write to their own notifications subcollection
          allow read, update, delete: if request.auth.uid == userId;
          // Allow creating notifications:
          // 1. Owner can create anything
          // 2. Others can create 'follow', 'reaction', 'comment' notifications
          allow create: if isAuthenticated() && (
            request.auth.uid == userId || 
            (
              (request.resource.data.type == 'follow' || 
               request.resource.data.type == 'reaction' || 
               request.resource.data.type == 'comment') &&
              // Check that the notification claims to be from the sender (using either userId or fromUserId)
              (
                (request.resource.data.keys().hasAny(['userId']) && request.resource.data.userId == request.auth.uid) ||
                (request.resource.data.keys().hasAny(['fromUserId']) && request.resource.data.fromUserId == request.auth.uid)
              )
            )
          );
      }
      // Allow user to read/write their own top-level notification doc
      // Allow others to increment unreadCount
      allow read: if request.auth.uid == userId;
      
      // Handle Create (if doc doesn't exist yet)
      allow create: if isAuthenticated() && (
        request.auth.uid == userId ||
        (
          request.resource.data.keys().hasOnly(['unreadCount']) &&
          request.resource.data.unreadCount == 1
        )
      );

      // Handle Update
      allow update: if isAuthenticated() && (
        request.auth.uid == userId ||
        (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['unreadCount']) &&
          (
            // If unreadCount exists, increment it
            (resource.data.keys().hasAny(['unreadCount']) && request.resource.data.unreadCount == resource.data.unreadCount + 1) ||
            // If unreadCount does NOT exist, set it to 1
            (!resource.data.keys().hasAny(['unreadCount']) && request.resource.data.unreadCount == 1)
          )
        )
      );
    }

    match /posts/{postId} {
      // Anyone can read posts
      allow read: if true;
      
      // Create: Users can create posts if logged in and are the author
      // Anonymous posts are allowed with proper fields set
      allow create: if request.auth != null 
        && request.resource.data.userId == request.auth.uid
        && (
          // Non-anonymous posts: must have isAnonymous false or not set
          (!request.resource.data.keys().hasAny(['isAnonymous']) || request.resource.data.isAnonymous == false)
          ||
          // Anonymous posts: must have correct anonymous fields
          (request.resource.data.isAnonymous == true 
           && request.resource.data.showProfileLink == false
           && request.resource.data.authorDisplayName == 'Anonymous')
        );
      
      // Update: 
      // 1. Owner can update everything EXCEPT isAnonymous
      // 2. Strangers can update likes, reactions, and counts
      allow update: if request.auth != null && (
        (resource.data.userId == request.auth.uid &&
         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['isAnonymous'])) ||
        (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likesCount', 'commentsCount', 'likes', 'reactions'])
        )
      );
      
      // Delete: Users can delete their own posts
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      
      match /comments/{commentId} {
        // Anyone can read comments
        allow read: if true;
        // Logged-in users can create comments (they own the comment)
        allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
        // Users can delete their own comments
        allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      }

      match /likes/{userId} {
        // Anyone can read likes
        allow read: if true;
        // Users can create/delete their own like (document ID is usually userId)
        allow create, delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Private author mapping for anonymous posts - SERVER ONLY ACCESS
    // This collection stores the real author ID for anonymous posts
    // Only Cloud Functions can read/write this collection
    match /posts_private/{postId} {
      allow read, write: if false;
    }

    // Stories collection
    match /stories/{storyId} {
      // Allow any authenticated user to read stories (to see friends' stories)
      allow read: if isAuthenticated();
      
      // Allow creating a story if the user is the owner
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      
      // Allow updating a story:
      // 1. Owner can update anything (though usually not needed)
      // 2. Any authenticated user can add themselves to the 'viewers' array
      allow update: if isAuthenticated() && (
        request.auth.uid == resource.data.userId ||
        (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewers']) &&
          request.resource.data.viewers.hasAll(resource.data.viewers) // Can only add viewers, not remove
        )
      );
      
      // Allow deleting a story if the user is the owner
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
  }
}
